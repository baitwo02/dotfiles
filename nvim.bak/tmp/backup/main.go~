package main

import (
  "fmt"
  "os"

  tea "github.com/charmbracelet/bubbletea"
  "github.com/charmbracelet/lipgloss"
  "github.com/charmbracelet/bubbles/textarea"
  "github.com/charmbracelet/bubbles/help"
	"github.com/charmbracelet/bubbles/key"
)

var (
	cursorStyle = lipgloss.NewStyle().
    Foreground(lipgloss.Color("212"))

	cursorLineStyle = lipgloss.NewStyle().
    Background(lipgloss.Color("57")).
    Foreground(lipgloss.Color("230"))

	placeholderStyle = lipgloss.NewStyle().
    Foreground(lipgloss.Color("238"))

	endOfBufferStyle = lipgloss.NewStyle().
    Foreground(lipgloss.Color("235"))

	focusedPlaceholderStyle = lipgloss.NewStyle().
    Foreground(lipgloss.Color("99"))

	focusedBorderStyle = lipgloss.NewStyle().
    Border(lipgloss.RoundedBorder()).
    BorderForeground(lipgloss.Color("238"))

	blurredBorderStyle = lipgloss.NewStyle().
    Border(lipgloss.HiddenBorder())
)

const (
  helpHeight = 5
)

type keymap struct {
  next, prev, quit key.Binding
}

type task struct {
  content string
  finished bool
  rank int
}

type model struct {
  monthTasks []task
  weekTasks []task
  dayTasks []task
  inputs []textarea.Model
  focusArea int // 当前焦点区域（"month"=0, "week"=1, "day"=2）
  width int
  height int
  keymap keymap
  help help.Model
}

func newTextarea() textarea.Model {
  t := textarea.New()
  t.Prompt = ""
  t.Placeholder = "Type something"
  t.ShowLineNumbers = true
  t.Cursor.Style = cursorStyle
  t.FocusedStyle.Placeholder = focusedPlaceholderStyle
  t.BlurredStyle.Placeholder = placeholderStyle
  t.FocusedStyle.CursorLine = cursorLineStyle
  t.FocusedStyle.Base = focusedBorderStyle
  t.BlurredStyle.Base = blurredBorderStyle
  t.FocusedStyle.EndOfBuffer = endOfBufferStyle
  t.BlurredStyle.EndOfBuffer = endOfBufferStyle
  t.KeyMap.DeleteWordBackward.SetEnabled(false)
  t.KeyMap.LineNext = key.NewBinding(key.WithKeys("down"))
  t.KeyMap.LinePrevious = key.NewBinding(key.WithKeys("up"))
  t.Blur()
  return t
}

func (m *model) sizeInputs() {
  m.inputs[0].SetWidth(m.width / 2)
  m.inputs[0].SetHeight(2*(m.height- helpHeight) / 3)
  m.inputs[1].SetWidth(m.width / 2)
  m.inputs[1].SetHeight((m.height- helpHeight) / 3)
  m.inputs[2].SetWidth(m.width / 2)
  // m.inputs[2].SetHeight(m.height- helpHeight)
  m.inputs[1].SetHeight((m.height- helpHeight) / 3)
}

func initialModel() model {
  m := model{
    inputs : make([]textarea.Model, 3),
    help: help.New(),
    keymap: keymap{
      next: key.NewBinding(
        key.WithKeys("tab"),
        key.WithHelp("tab", "next"),
      ),
      prev: key.NewBinding(
        key.WithKeys("shitf+tab"),
        key.WithHelp("shitf+tab", "prev"),
      ),
      quit: key.NewBinding(
        key.WithKeys("esc", "ctrl+c"),
        key.WithHelp("esc", "quit"),
      ),
    },
  }
  for i:=0;i<3;i++ {
    m.inputs[i] = newTextarea()
  }
  m.focusArea = 2
  return m
}

func (m model) Init() tea.Cmd {
  return textarea.Blink
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
  var cmds []tea.Cmd

  switch msg := msg.(type) {
  case tea.KeyMsg:
    switch {
    case key.Matches(msg, m.keymap.quit):
      for i := range m.inputs {
        m.inputs[i].Blur()
      }
      return m, tea.Quit
    case key.Matches(msg, m.keymap.next):
      m.inputs[m.focusArea].Blur()
      m.focusArea++
      m.focusArea = m.focusArea % 3
      cmd := m.inputs[m.focusArea].Focus()
      cmds = append(cmds, cmd)
    case key.Matches(msg, m.keymap.prev):
      m.inputs[m.focusArea].Blur()
      m.focusArea--
      m.focusArea = m.focusArea % 3
      cmd := m.inputs[m.focusArea].Focus()
      cmds = append(cmds, cmd)
    }
  case tea.WindowSizeMsg:
    m.height = msg.Height
    m.width = msg.Width
  }

  m.sizeInputs()

  for i := range m.inputs {
    newModel, cmd := m.inputs[i].Update(msg)
    m.inputs[i] = newModel
    cmds = append(cmds, cmd)
  }

  return m, tea.Batch(cmds...)
}

func (m model) View() string {
  help := m.help.ShortHelpView([]key.Binding{
    m.keymap.next,
    m.keymap.prev,
    m.keymap.quit,
  })
  
  var view string
  // view = lipgloss.JoinVertical(lipgloss.Left, m.inputs[0].View(), m.inputs[1].View())
  // view = lipgloss.JoinHorizontal(lipgloss.Top, view, m.inputs[1].View())
  view = lipgloss.JoinVertical(lipgloss.Top, m.inputs[0].View(), m.inputs[1].View(), m.inputs[2].View())

  return view + "\n\n" + help
}

func main() {
    p := tea.NewProgram(initialModel(), tea.WithAltScreen())
    if _, err := p.Run(); err != nil {
        fmt.Printf("Alas, there's been an error: %v", err)
        os.Exit(1)
    }
}

