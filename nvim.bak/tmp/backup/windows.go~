package main

import (
	"fmt"
	"log"
	"time"

	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/bubbles/timer"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type sessionState uint

const (
	defaultTime              = time.Minute
	timerView   sessionState = iota
	spinnerView
)

var (
	spinners = []spinner.Spinner{
		spinner.Line,
		spinner.Dot,
		spinner.MiniDot,
		spinner.Jump,
		spinner.Pulse,
		spinner.Points,
		spinner.Globe,
		spinner.Moon,
		spinner.Monkey,
	}
	modelStyle = lipgloss.NewStyle().
			Width(15).
			Height(5).
			Align(lipgloss.Center, lipgloss.Center).
			BorderStyle(lipgloss.HiddenBorder())
	focusedModelStyle = lipgloss.NewStyle().
				Width(15).
				Height(5).
				Align(lipgloss.Center, lipgloss.Center).
				BorderStyle(lipgloss.NormalBorder()).
				BorderForeground(lipgloss.Color("69"))
	spinnerStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("69"))
	helpStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("241"))
)

type windowModel struct {
  state sessionState
  timer timer.Model
  spinner spinner.Model
  index int
}

func newModel(timeout time.Duration) windowModel {
  m := windowModel{state: timerView}
  m.timer = timer.New(timeout)
  m.spinner = spinner.New()
  return m
}

func (m windowModel) Init() tea.Cmd {
  return tea.Batch(m.timer.Init(), m.spinner.Tick)
}

func (m windowModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
  var cmd tea.Cmd
  var cmds []tea.Cmd
  switch msg := msg.(type) {
  case tea.KeyMsg:
    switch msg.String() {
    case "ctrl+c", "q":
      return m, tea.Quit
    case "tab":
      if m.state == timerView {
        m.state = spinnerView
      } else {
        m.state = timerView
      }
    case "n":
      if m.state == timerView {
        m.timer = timer.New(defaultTime)
        cmds = append(cmds, m.timer.Init())
      } else {
        m.Next()
        m.resetSpinner()
        cmds = append(cmds, m.spinner.Tick)
      }
    }
    switch m.state {
    case spinnerView:
      m.spinner, cmd = m.spinner.Update(msg)
      cmds = append(cmds, cmd)
    default:
      m.timer, cmd = m.timer.Update(msg)
      cmds = append(cmds, cmd)
    }
  case spinner.TickMsg:
    m.spinner, cmd = m.spinner.Update(msg)
    cmds = append(cmds, cmd)
  case timer.TickMsg:
    m.timer, cmd = m.timer.Update(msg)
    cmds = append(cmds, cmd)
  }
  return m, tea.Batch(cmds...)
}

func (m windowModel) View() string {
  var s string
  model := m.currentTocusedModel()
  if m.state == timerView {
    s += lipgloss.JoinHorizontal(lipgloss.Top, focusedModelStyle.Render(fmt.Sprintf("%4s", m.timer.View())), modelStyle.Render(m.spinner.View()))
  } else {
    s += lipgloss.JoinHorizontal(lipgloss.Top, modelStyle.Render(fmt.Sprintf("%4s", m.timer.View())), focusedModelStyle.Render(m.spinner.View()))
  }
  s += helpStyle.Render(fmt.Sprintf("\ntab: focus next -- n: new %s -- q: exit\n", model))
  return s
}

func (m windowModel) currentTocusedModel() string {
  if m.state == timerView {
    return "timer"
  } else {
    return "spinner"
  }
}

func (m *windowModel) Next() {
  if m.index == len(spinners) - 1 {
    m.index = 0
  } else {
    m.index++
  }
}

func (m *windowModel) resetSpinner() {
  m.spinner = spinner.New()
  m.spinner.Style = spinnerStyle
  m.spinner.Spinner = spinners[m.index]
}

func 

