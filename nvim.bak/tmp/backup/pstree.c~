#include <assert.h>
#include <stdio.h>

#include <dirent.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// 定義二叉樹儲存 pstree
typedef struct process_tree {
  int32_t pid;
  int32_t ppid;
  char name[255];
  struct process_tree *child;
  struct process_tree *brother;
} process_node;

// 判断是否为数字
int is_numeric(char *str) {
  for (int i = 0; str[i] != '\0'; i++) {
    if (str[i] < 48 || str[i] > 57) {
      return 0;
    }
  }
  return 1;
}

// 处理名字
void process_name(char *p_name, char *unp_name) {
  int index_p_name = 0;
  for (int i = 0; unp_name[i] != '\0'; i++) {
    if (unp_name[i] != '(' && unp_name[i] != ')') {
      p_name[index_p_name] = unp_name[i];
      index_p_name++;
    }
  }
  p_name[index_p_name] = '\0';
}

// 讀取節點信息
int get_info(process_node *node, char *path) {
  int get_info_flag;
  FILE *ptr_file;
  char pid_char[255];
  char o_name[255];
  char name[255];
  char _[255];
  char ppid_char[255];

  ptr_file = fopen(path, "r");
  if (ptr_file == NULL) {
    printf("Faild to open file %s!\n", path);
    get_info_flag = 0;
    return get_info_flag;
  }

  fscanf(ptr_file, "%s %s %s %s", pid_char, o_name, _, ppid_char);
  fclose(ptr_file);
  process_name(name, o_name);
  node->pid = atoi(pid_char);
  node->ppid = atoi(ppid_char);
  strcpy(node->name, name);
  // printf("%6s %40s %2s %6s\n", pid_char, name, _, ppid_char);
  get_info_flag = 1;
  return get_info_flag;
}

// 增加子节点
void add_child_node(process_node *parent_node, process_node *child) {
  process_node *tmp;
  tmp = parent_node->child;

  if (tmp == NULL) {
    parent_node->child = child;
    return;
  } else {
    while (tmp->brother) {
      tmp = tmp->brother;
    }
    tmp->brother = child;
  }
  // printf("add child %-30s to %-30s\n", child->name, parent_node->name);
}

// 拼接路径
void get_path(char *path, char *part1, char *part2) {
  snprintf(path, 255, "%s/%s/%s", part1, part2, "stat");
}

// 遍历进程树
void search_tree(process_node *tree, process_node **tar_node, int32_t pid) {
  if (tree != NULL) {
    if (tree->pid == pid) {
      *tar_node = tree;
      return;
    }
    search_tree(tree->brother, tar_node, pid);
    search_tree(tree->child, tar_node, pid);
  }
}

// 獲取進程樹
void get_tree(process_node *tree) {
  strcpy(tree->name, "root");
  tree->pid = 0;
  char proc_path[] = "/proc";
  DIR *ptr_dir;
  struct dirent *entry;

  ptr_dir = opendir(proc_path);
  if (ptr_dir == NULL) {
    printf("Faild to open dir %s!", proc_path);
  }
  process_node *tmp;
  process_node *parent_node;
  while ((entry = readdir(ptr_dir))) {
    if (!is_numeric(entry->d_name)) {
      continue;
    }
    tmp = (process_node *)malloc(sizeof(process_node));
    char path[255];
    get_path(path, proc_path, entry->d_name);
    if (!get_info(tmp, path)) {
      continue;
    }
    search_tree(tree, &parent_node, tmp->ppid);
    add_child_node(parent_node, tmp);
  }
  closedir(ptr_dir);
}

void print_tree_nopid(process_node *node, char *prefix, int from) {
  // │ └ ├ ─ ┬
  if (from == 2 && node == NULL) {
    return;
  } else if (from == 1 && node == NULL){
    fprintf(stderr, "\n");
    return;
  }

  char *str;
  asprintf(&str, "%s  │  ", prefix);
  fprintf(stderr, "%s", prefix);
  if (from == 1 && node->brother) {
    fprintf(stderr, "%d", node->brother);
    printf("1");
    printf("\b\b\b\b\b──┬──");
    fprintf(stderr, "%s", node->name);
  } else if (from == 1 && !node->brother) {
    printf("\b\b\b   ");
    fprintf(stderr, "%s", node->name);
  } else if (from == 0) {
    fprintf(stderr, "%s", node->name);
  }
  print_tree_nopid(node->child, str, 1);
  print_tree_nopid(node->brother, str, 2);
  free(str);

}

int main(int argc, char *argv[]) {
  for (int i = 0; i < argc; i++) {
    assert(argv[i]);
    printf("argv[%d] = %s\n", i, argv[i]);
  }
  process_node *root;
  root = (process_node *)malloc(sizeof(process_node));
  root->pid = 1;
  get_tree(root);
  while (!strcmp(root->child->name, "systemd")) {
    root = root->child;
  }
  root->brother = NULL;
  char prefix[] = "";
  print_tree_nopid(root, prefix, 0);

  assert(!argv[argc]);
  return 0;
}
